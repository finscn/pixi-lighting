!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t.PIXI=t.PIXI||{},t.PIXI.lighting={}))}(this,function(t){"use strict";PIXI.Circle.prototype.getMesh=function(t,e,r){void 0===t&&(t=40),e=e||new Float32Array(2*(t+1)),r=r||new Uint16Array(t+1);var i=2*Math.PI/t,n=-1;r[++n]=n;for(var o=0;o<=t;++o){var a=2*o,s=i*o;e[a]=Math.cos(s)*this.radius,e[a+1]=Math.sin(s)*this.radius,r[++n]=n}return r[n]=1,{verticesOutput:e,indicesOutput:r}};var e=PIXI.utils,r=PIXI.Shader,i=PIXI.BLEND_MODES,n=function(t){t=t||{},this.position=t.position||{x:0,y:0},"z"in this.position||(this.position.z=10),this.position.set=function(t,e,r){this.x=t,this.y=e,this.z=void 0!==r?r:this.z},this.positionArray=new Float32Array(3),this.falloff=new Float32Array(t.falloff||[.75,3,20]),this.colorArray=new Float32Array([0,0,0]),this._color=5592405,this._brightness=1,this._colorRgb=new Float32Array([.33,.33,.33]),"color"in t&&(this.color=t.color),"brightness"in t&&(this.brightness=t.brightness),this.invertRed=!1,"invertRed"in t&&(this.invertRed=t.invertRed),this.invertGreen=!1,"invertGreen"in t&&(this.invertGreen=t.invertGreen),this.precision="lowp","precision"in t&&(this.precision=t.precision),this.blendMode=i.ADD,this.visible=!1,this.shaderName=null,this.needsUpdate=!0,this.inited=!1},o={color:{configurable:!0},brightness:{configurable:!0}};n.prototype.init=function(t,e){if(!this.inited||e){var r=t.gl;this.viewSize=new Float32Array([t.width,t.height]),this.shader=this.generateShader(r),this.inited=!0}},n.prototype.generateShader=function(t){var e=this.getVertexSource(),i=this.getFragmentSource();if(this.invertRed){var o="normalColor.r = 1.0 - normalColor.r;";i=i.replace("// "+o,o)}if(this.invertGreen){var a="normalColor.g = 1.0 - normalColor.g;";i=i.replace(a,"// "+a)}var s=e+"@"+i,l=n.shaderCache[s];return l||(n.shaderCache[s]=l,l=new r(t,e,i,n.locationMapping,this.precision)),l},n.prototype.getVertexSource=function(){},n.prototype.getFragmentSource=function(){},n.prototype.updateColor=function(){var t=this.colorArray,e=this._colorRgb,r=this._brightness;t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r},n.prototype.syncShader=function(){var t=this.shader;t.uniforms.uViewSize=this.viewSize,t.uniforms.uLightColor=this.colorArray,t.uniforms.uLightFalloff=this.falloff},o.color.get=function(){return this._color},o.color.set=function(t){this._color=t,e.hex2rgb(t||0,this._colorRgb),this.updateColor()},o.brightness.get=function(){return this._brightness},o.brightness.set=function(t){this._brightness=t,this.updateColor()},Object.defineProperties(n.prototype,o),n.shaderCache={},n.locationMapping={aVertexPosition:0,aTextureCoord:1,aNormalTextureCoord:2};var a=PIXI.utils,s=PIXI.BLEND_MODES,l=function(t){function e(e){e=e||{},t.call(this,e),this.blendMode=s.ADD,this.ambientColorArray=new Float32Array([0,0,0]),this._ambientColorRgb=new Float32Array([0,0,0]),this._ambientColor=null,this._ambientBrightness=1,"ambientColor"in e&&(this.ambientColor=e.ambientColor),"ambientBrightness"in e&&(this.ambientBrightness=e.ambientBrightness)}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var r={ambientColor:{configurable:!0},ambientBrightness:{configurable:!0}};return e.prototype.updateAmbientColor=function(){var t=this.ambientColorArray,e=this._ambientColorRgb,r=this._ambientBrightness;t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r},e.prototype.syncShader=function(){var t=this.shader;t.uniforms.uViewSize=this.viewSize,t.uniforms.uLightColor=this.colorArray,t.uniforms.uLightFalloff=this.falloff,t.uniforms.uAmbientColor=this.ambientColorArray},r.ambientColor.get=function(){return this._ambientColor},r.ambientColor.set=function(t){this._ambientColor=t,a.hex2rgb(t||0,this._ambientColorRgb),this.updateAmbientColor(),this.blendMode=null===t?s.ADD:s.NORMAL},r.ambientBrightness.get=function(){return this._ambientBrightness},r.ambientBrightness.set=function(t){this._ambientBrightness=t,this.updateAmbientColor()},Object.defineProperties(e.prototype,r),e}(n),u=PIXI.BLEND_MODES,h=function(t){function e(e){e=e||{},t.call(this,e),this.position.x=0,this.position.y=0,this.position.z=0,this.falloff=new Float32Array([1,0,0]),this.blendMode=u.NORMAL,this.shaderName="ambientLightShader"}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getVertexSource=function(){return"\n\n\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec2 aNormalTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vNormalTextureCoord;\n\n\n\nvoid main(void) {\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormalTextureCoord = aNormalTextureCoord;\n}\n\n"},e.prototype.getFragmentSource=function(){return'\n\n\n\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\n// light color, has multiplied bright for intensity.\nuniform vec3 uLightColor;\n\n// light attenuation coefficients (constant, linear, quadratic)\nuniform vec3 uLightFalloff;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vNormalTextureCoord;\n\nuniform vec2 uViewSize;\n\nuniform mat3 uWorldMatrix;\nuniform bool uFixedNormal;\n\n\n\nvoid main(void)\n{\n\n\n\nvec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n\n// bail out early when diffuse has no data\nif (diffuseColor.a == 0.0) {\n   discard;\n}\n\n\n\n\nvec4 normalColor = texture2D(uNormalSampler, vNormalTextureCoord);\n\n// Red layer is X coords.\n// normalColor.r = 1.0 - normalColor.r;\n\n// Green layer is flipped Y coords.\nnormalColor.g = 1.0 - normalColor.g;\n\n\n\n    uViewSize;\n\n    // simplified lambert shading that makes assumptions for ambient color\n\n    // compute Distance\n    float D = 1.0;\n\n\n\n// normalize vectors\nvec3 normal3 = vec3(normalColor.xyz * 2.0 - 1.0);\nvec3 N = normalize(\n        uFixedNormal ?\n            normal3 :\n            vec3((uWorldMatrix * vec3(normal3.xy, 0.0)).xy , normal3.z)\n    );\n\n\n\n    vec3 L = vec3(1.0, 1.0, 1.0);\n\n    // pre-multiply light color with intensity\n    // then perform "N dot L" to determine our diffuse\n    vec3 diffuse = uLightColor * max(dot(N, L), 0.0);\n\n    vec3 finalColor = diffuseColor.rgb * diffuse;\n\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n\n'},e}(n),c=function(t){function e(e){e=e||{},t.call(this,e),this.target=e.target||{x:0,y:0},"z"in this.target||(this.target.z=10),this.directionArray=new Float32Array(3),this.updateDirection(),this.shaderName="directionalLightShader"}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getVertexSource=function(){return"\n\n\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec2 aNormalTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vNormalTextureCoord;\n\n\n\nvoid main(void) {\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormalTextureCoord = aNormalTextureCoord;\n}\n\n"},e.prototype.getFragmentSource=function(){return'\n\n// imports the common uniforms like samplers, and ambient/light color\n\n\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\n// light color, has multiplied bright for intensity.\nuniform vec3 uLightColor;\n\n// light attenuation coefficients (constant, linear, quadratic)\nuniform vec3 uLightFalloff;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vNormalTextureCoord;\n\nuniform vec2 uViewSize;\n\nuniform mat3 uWorldMatrix;\nuniform bool uFixedNormal;\n\n\n\nuniform vec3 uAmbientColor;\nuniform vec3 uLightDirection;\n\nvoid main()\n{\n\n\n\nvec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n\n// bail out early when diffuse has no data\nif (diffuseColor.a == 0.0) {\n   discard;\n}\n\n\n\n\nvec4 normalColor = texture2D(uNormalSampler, vNormalTextureCoord);\n\n// Red layer is X coords.\n// normalColor.r = 1.0 - normalColor.r;\n\n// Green layer is flipped Y coords.\nnormalColor.g = 1.0 - normalColor.g;\n\n\n\n    // the directional vector of the light\n    vec3 lightVector = uLightDirection;\n\n    // correct for aspect ratio\n    lightVector.y *= uViewSize.y / uViewSize.x;\n\n    // compute Distance\n    // float D = length(lightVector);\n\n\n\n// normalize vectors\nvec3 normal3 = vec3(normalColor.xyz * 2.0 - 1.0);\nvec3 N = normalize(\n        uFixedNormal ?\n            normal3 :\n            vec3((uWorldMatrix * vec3(normal3.xy, 0.0)).xy , normal3.z)\n    );\n\n\n\n    vec3 L = normalize(lightVector);\n\n    // pre-multiply light color with intensity\n    // then perform "N dot L" to determine our diffuse\n    vec3 diffuse = uLightColor * max(dot(N, L), 0.0);\n\n    // calculate attenuation\n    float attenuation = 1.0;\n\n    // calculate final intesity and color, then combine\n    vec3 intensity = uAmbientColor + diffuse * attenuation;\n\n    vec3 finalColor = diffuseColor.rgb * intensity;\n\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n\n'},e.prototype.updateDirection=function(){var t=this.directionArray,e=this.target.x,r=this.target.y,i=this.target.z;t[0]=this.position.x-e,t[1]=this.position.y-r,t[2]=this.position.z-i},e.prototype.syncShader=function(e){t.prototype.syncShader.call(this,e),this.shader.uniforms.uLightDirection=this.directionArray},e}(l),d=PIXI.utils,f=function(t){function e(e){e=e||{},t.call(this,e),this.radius=e.radius||1/0,this.shaderName="pointLightShader"}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var r={ambientLightColor:{configurable:!0},ambientLightBrightness:{configurable:!0}};return e.prototype.getVertexSource=function(){return"\n\n\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec2 aNormalTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vNormalTextureCoord;\n\n\n\nvarying float flippedY;\n\nvoid main(void) {\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormalTextureCoord = aNormalTextureCoord;\n\n    flippedY = projectionMatrix[1][1] < 0.0 ? 1.0 : 0.0;\n}\n\n"},e.prototype.getFragmentSource=function(){return"\n\n// imports the common uniforms like samplers, and ambient color\n\n\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\n// light color, has multiplied bright for intensity.\nuniform vec3 uLightColor;\n\n// light attenuation coefficients (constant, linear, quadratic)\nuniform vec3 uLightFalloff;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vNormalTextureCoord;\n\nuniform vec2 uViewSize;\n\nuniform mat3 uWorldMatrix;\nuniform bool uFixedNormal;\n\n\n\nvarying float flippedY;\n\nuniform vec3 uAmbientColor;\nuniform vec3 uLightPosition;\nuniform float uLightRadius;\n\nvoid main()\n{\n\n\n\nvec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n\n// bail out early when diffuse has no data\nif (diffuseColor.a == 0.0) {\n   discard;\n}\n\n\n\n\nvec4 normalColor = texture2D(uNormalSampler, vNormalTextureCoord);\n\n// Red layer is X coords.\n// normalColor.r = 1.0 - normalColor.r;\n\n// Green layer is flipped Y coords.\nnormalColor.g = 1.0 - normalColor.g;\n\n\n\n    vec2 fragCoord = gl_FragCoord.xy / uViewSize.xy;\n\n    // FBOs positions are flipped.\n    fragCoord.y = flippedY > 0.0 ? 1.0 - fragCoord.y : fragCoord.y;\n\n    vec3 lightPosition = uLightPosition / vec3(uViewSize, uViewSize.x);\n    float lightRadius = uLightRadius / uViewSize.x;\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(lightPosition.xy - fragCoord, lightPosition.z);\n\n    // correct for aspect ratio\n    lightVector.y *= uViewSize.y / uViewSize.x;\n\n    // compute Distance\n    float D = length(lightVector);\n\n    vec3 intensity = uAmbientColor;\n    // bail out early when pixel outside of light sphere\n    if (D <= lightRadius) {\n\n\n\n// normalize vectors\nvec3 normal3 = vec3(normalColor.xyz * 2.0 - 1.0);\nvec3 N = normalize(\n        uFixedNormal ?\n            normal3 :\n            vec3((uWorldMatrix * vec3(normal3.xy, 0.0)).xy , normal3.z)\n    );\n\n\n\n        // vec3 L = normalize(lightVector);\n        vec3 L = lightVector / D;\n\n        // pre-multiply light color with intensity\n        // then perform N dot L to determine our diffuse\n        vec3 diffuse = uLightColor * max(dot(N, L), 0.0);\n\n        // calculate attenuation\n        float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\n\n        // calculate final intesity and color, then combine\n        intensity += diffuse * attenuation;\n    }\n\n    // TODO : roughness\n    // TODO : finalColor = ambient + diffuse + specular\n\n    vec3 finalColor = diffuseColor.rgb * intensity;\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n\n"},e.prototype.syncShader=function(e){t.prototype.syncShader.call(this,e),this.positionArray[0]=this.position.x+(e.lightOffsetX||0),this.positionArray[1]=this.position.y+(e.lightOffsetY||0),this.positionArray[2]=this.position.z+(e.lightOffsetZ||0),this.shader.uniforms.uLightPosition=this.positionArray,this.shader.uniforms.uAmbientLightColor=this._ambientLightColorRgba,this.shader.uniforms.uLightRadius=this.radius},r.ambientLightColor.get=function(){return this._ambientLightColor},r.ambientLightColor.set=function(t){this._ambientLightColor=t,d.hex2rgb(t,this._ambientColorRgba)},r.ambientLightBrightness.get=function(){return this._ambientLightColorRgba[3]},r.ambientLightBrightness.set=function(t){this._ambientLightColorRgba[3]=t},Object.defineProperties(e.prototype,r),e}(l);var m=PIXI.glCore,v=function(t,e){this.gl=t,this.vertSize=6,this.vertByteSize=4*this.vertSize,this.vertices=new Float32Array([-1,-1,1,-1,1,1,-1,1]),this.uvs=new Float32Array([0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1]),this.interleaved=new Float32Array(24);for(var r=0;r<4;r++)this.interleaved[6*r]=this.vertices[2*r],this.interleaved[6*r+1]=this.vertices[2*r+1],this.interleaved[6*r+2]=this.uvs[2*r],this.interleaved[6*r+3]=this.uvs[2*r+1],this.interleaved[6*r+4]=this.uvs[2*r+8],this.interleaved[6*r+5]=this.uvs[2*r+1+8];this.indices=function(t){for(var e=6*t,r=new Uint16Array(e),i=0,n=0;i<e;i+=6,n+=4)r[i+0]=n+0,r[i+1]=n+1,r[i+2]=n+2,r[i+3]=n+0,r[i+4]=n+2,r[i+5]=n+3;return r}(1),this.vertexBuffer=m.GLBuffer.createVertexBuffer(t,this.interleaved,t.STATIC_DRAW),this.indexBuffer=m.GLBuffer.createIndexBuffer(t,this.indices,t.STATIC_DRAW),this.vao=new m.VertexArrayObject(t,e)};v.prototype.initVao=function(t){this.vao.clear().addIndex(this.indexBuffer).addAttribute(this.vertexBuffer,t.attributes.aVertexPosition,this.gl.FLOAT,!1,this.vertByteSize,0).addAttribute(this.vertexBuffer,t.attributes.aTextureCoord,this.gl.FLOAT,!1,this.vertByteSize,8).addAttribute(this.vertexBuffer,t.attributes.aNormalTextureCoord,this.gl.FLOAT,!1,this.vertByteSize,16)},v.prototype.map=function(t,e){var r=0,i=0;return this.uvs[0]=r,this.uvs[1]=i,this.uvs[2]=r+e.width/t.width,this.uvs[3]=i,this.uvs[4]=r+e.width/t.width,this.uvs[5]=i+e.height/t.height,this.uvs[6]=r,this.uvs[7]=i+e.height/t.height,r=e.x,i=e.y,this.vertices[0]=r,this.vertices[1]=i,this.vertices[2]=r+e.width,this.vertices[3]=i,this.vertices[4]=r+e.width,this.vertices[5]=i+e.height,this.vertices[6]=r,this.vertices[7]=i+e.height,this},v.prototype.upload=function(){for(var t=0;t<4;t++)this.interleaved[6*t]=this.vertices[2*t],this.interleaved[6*t+1]=this.vertices[2*t+1],this.interleaved[6*t+2]=this.uvs[2*t],this.interleaved[6*t+3]=this.uvs[2*t+1],this.interleaved[6*t+4]=this.uvs[2*t+8],this.interleaved[6*t+5]=this.uvs[2*t+1+8];return this.vertexBuffer.upload(this.interleaved),this},v.prototype.destroy=function(){var t=this.gl;t.deleteBuffer(this.vertexBuffer),t.deleteBuffer(this.indexBuffer)};var g=PIXI.Texture,p=PIXI.WebGLRenderer,y=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.onContextChange=function(){this.gl=this.renderer.gl,this.quad=new v(this.gl,this.renderer.state.attribState),n.shaderCache={},this.contextChanged=!0},e.prototype.render=function(t){if(t._texture._uvs&&t.lights){var r,i=this.renderer,n=i.gl,o=t.lights,a=o.length,s=t.computedGeometry?t.computedGeometry.vertices:t.vertexData,l=t.diffuseTexture?t.diffuseTexture:t._texture,u=t.normalTexture?t.normalTexture:e.defaultNormalTexture,h=t.worldTransform.toArray(!0),c=l._uvs,d=u._uvs,f=i.bindTexture(l,1,!0);r=l.baseTexture===u.baseTexture?f:i.bindTexture(u,2,!0);for(var m=null,v=0;v<a;v++){var g=o[v];g.init(i,this.contextChanged);var p=g.shader;if(0===v){var y=this.quad,x=y.vertices,b=y.uvs;i.bindVao(null),y.initVao(p);for(var C=0;C<8;C++)x[C]=s[C];b[0]=c.x0,b[1]=c.y0,b[2]=c.x1,b[3]=c.y1,b[4]=c.x2,b[5]=c.y2,b[6]=c.x3,b[7]=c.y3,b[8]=d.x0,b[9]=d.y0,b[10]=d.x1,b[11]=d.y1,b[12]=d.x2,b[13]=d.y2,b[14]=d.x3,b[15]=d.y3,y.upload(),i.bindVao(y.vao)}m!==p&&(m=p,i.bindShader(p)),p.uniforms.uSampler=f,p.uniforms.uNormalSampler=r,p.uniforms.uWorldMatrix=h,p.uniforms.uFixedNormal=!!t.fixedNormal,g.syncShader(t),i.state.setBlendMode(g.blendMode),n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0)}this.contextChanged=!1}},e.prototype.destroy=function(){t.prototype.destroy.call(this)},e}(PIXI.ObjectRenderer),x=document.createElement("canvas"),b=x.getContext("2d");x.width=x.height=10,b.fillStyle="#8080FF",b.fillRect(0,0,x.width,x.height),y.defaultNormalTexture=g.from(x),y.pluginName="lightSprite",p.registerPlugin(y.pluginName,y);var C=function(){};C.applyTo=function(t){var e={};e.pluginName=t.pluginName,e._renderWebGL=t._renderWebGL,e._texturee=t._texture,t.pluginName=y.pluginName,t._renderWebGL=C.prototype._renderWebGL,t._lightingBackup=e},C.unapplyTo=function(t){if(t._lightingBackup){var e=t._lightingBackup;t.pluginName=e.pluginName,t._renderWebGL=e._renderWebGL,t._texture=e._texture,t._lightingBackup=null}},C.prototype._renderWebGL=function(t){if(this.calculateVertices(),t.renderingDiffuses){var e=this.diffuseTexture||this._texture;this._texture=e;var r=t.plugins.sprite;return t.setObjectRenderer(r),void r.render(this)}if(t.renderingNormals){var i=this.normalTexture||y.defaultNormalTexture;this._texture=i;var n=t.plugins.sprite;return t.setObjectRenderer(n),void n.render(this)}var o=t.plugins.lightSprite;t.setObjectRenderer(o),o.render(this)},t.Light=n,t.LightWithAmbient=l,t.AmbientLight=h,t.DirectionalLight=c,t.PointLight=f,t.LightSpriteRenderer=y,t.LightTarget=C,Object.defineProperty(t,"__esModule",{value:!0})});